# -*- coding: utf-8 -*-
"""jh_marketing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ahKTswdeuKXVD_UHovA7VjQsqNS_q7zV
"""

import numpy as np
import pandas as pd
import sqlite3 as sql
import os 
import plotly.graph_objs as go 
import plotly.express as px
import matplotlib.pyplot as plt

!pip install surprise
from surprise import Reader, Dataset
from surprise.model_selection import cross_validate, GridSearchCV
from surprise import KNNBasic, KNNWithMeans, KNNWithZScore, KNNBaseline
from surprise.model_selection import train_test_split

from google.colab import drive
drive.mount('/content/drive')

"""### **Exploración**"""

os.getcwd()
os.chdir('/content/drive/MyDrive/Analítica 3 para dummies ')

conn=sql.connect('/content/drive/MyDrive/Analítica 3 para dummies /db_movies')
cur = conn.cursor()

cur.execute("SELECT name FROM sqlite_master WHERE type='table';")
print(cur.fetchall())

movies = pd.read_sql('select * from movies', conn)
movies

ratings = pd.read_sql('select * from ratings', conn)
ratings

movies.info()
movies.duplicated().sum()

ratings.info()
ratings.duplicated().sum()

# 10 peliculas mas vistas 
vistas = pd.read_sql(''' Select title as pelicula,
                         count(*) as vistas
                         from movies inner join ratings on
                         movies.movieID = ratings.movieId
                         group by title
                         order by vistas desc limit 10
                         ''',conn )

plt.barh(vistas['pelicula'], vistas['vistas'])
plt.xlabel('Número de vistas')
plt.ylabel('Películas')
plt.title('Películas más vistas')
plt.show()

# dispersion de las calificaciones de peliculas 
calificaciones = pd.read_sql('''SELECT title, COUNT(ratings.rating) as num_ratings, AVG(ratings.rating) as avg_rating
                FROM movies
                LEFT JOIN ratings ON movies.movieId = ratings.movieId
                GROUP BY title''',conn)

plt.scatter(calificaciones['num_ratings'], calificaciones['avg_rating'], alpha=0.5)
plt.title('Diagrama de dispersión de calificaciones de películas')
plt.xlabel('Número de calificaciones')
plt.ylabel('Calificación media')
plt.show()

# Peliculas con mas de un genero
pd.read_sql('''SELECT title, genres
                FROM movies
                WHERE LENGTH(genres) - LENGTH(REPLACE(genres, '|', '')) >= 1
                limit 10
                         ''',conn )

# Peliculas con calificacion de 5 
pd.read_sql('''SELECT title, rating
                From movies inner join ratings on
                Movies.movieID = ratings.movieId
                WHERE rating = 5.0
                         ''',conn )

###calcular la distribución de calificaciones
distribucion = pd.read_sql(""" select 
                                    rating as calificacion, 
                                    count(*) as conteo 
                                    from ratings
                                    group by rating
                                    order by conteo desc""", conn)
distribucion

data  = go.Bar( x=distribucion.calificacion,y=distribucion.conteo, text=distribucion.conteo, textposition="outside")
Layout=go.Layout(title="Count of ratings",xaxis={'title':'Rating'},yaxis={'title':'Count'})
go.Figure(data,Layout)

rating_users=pd.read_sql(''' select userId as user_id,
                         count(*) as cnt_rat
                         from ratings
                         group by userId
                         order by cnt_rat asc
                         ''',conn )

rating_users.tail(50)

fig  = px.histogram(rating_users, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones por usario')
fig.show()

rating_users.describe()

rating_users2 = pd.read_sql(''' select UserId as user_id,
                         count(*) as cnt_rat
                         from ratings
                         group by userId
                         having cnt_rat <=1055
                         order by cnt_rat asc
                         ''',conn )
rating_users2

rating_users2.describe()

### graficar distribucion despues de filtrar datos
fig  = px.histogram(rating_users2, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones por usario')
fig.show()

#### verificar cuantas calificaciones tiene cada pelicula
rating_movies=pd.read_sql(''' select title,
                         count(*) as cnt_rat
                         from movies inner join ratings on
                         movies.movieID = ratings.movieId
                         group by title 
                         order by cnt_rat desc
                         ''',conn )

rating_movies

rating_movies.describe()

fig  = px.histogram(rating_movies, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones para cada pelicula')
fig.show()

####Filtrar pelicula que tengan 5 o más calificaciones 
rating_movies2 = pd.read_sql(''' select title ,
                         count(*) as cnt_rat
                         from movies inner join ratings on
                         movies.movieID = ratings.movieId
                         group by title
                         having cnt_rat>= 5
                         order by cnt_rat desc
                         ''',conn )

rating_movies2.describe()

fig  = px.histogram(rating_movies2, x= 'cnt_rat', title= 'Hist frecuencia de numero de calificaciones para cada pelicula')
fig.show()

"""###**Creación tablas**###

"""

# Filtro de usuarios con menos de 1055 calificaciones
with sql.connect('/content/drive/MyDrive/Analítica 3 para dummies /db_movies') as conn:
  conn.execute("DROP TABLE IF EXISTS usuarios_sel")
  conn.execute("""CREATE TABLE usuarios_sel as
                  SELECT UserId, count(*) as cnt_rat_user
                  FROM ratings
                  GROUP BY userId
                  HAVING cnt_rat_user <=1055
                  ORDER BY cnt_rat_user ASC""")

pd.read_sql('select * from usuarios_sel', conn)

# Filtro de peliculas con mayor a 5 calificaciones 
with sql.connect('/content/drive/MyDrive/Analítica 3 para dummies /db_movies') as conn:
  conn.execute("DROP TABLE IF EXISTS movies_sel;")
  conn.execute("""CREATE TABLE movies_sel as 
              SELECT title, count(*) as cnt_rat_movies
              FROM movies inner join ratings on
              movies.movieID = ratings.movieId
              GROUP BY title
              HAVING cnt_rat_movies >= 5
              ORDER BY cnt_rat_movies desc
              """)

pd.read_sql('select * from movies_sel', conn)

# Base de datos Movies final
with sql.connect('/content/drive/MyDrive/Analítica 3 para dummies /db_movies') as conn:
  conn.execute("DROP TABLE IF EXISTS movies_final")
  conn.execute("""CREATE TABLE movies_final as
                  SELECT movieId, movies.title, genres, cnt_rat_movies    
                  FROM movies
                  inner join movies_sel
                  on movies.title = movies_sel.title""")

pd.read_sql('select * from movies_final', conn)

# Base de datos Ratings final
with sql.connect('/content/drive/MyDrive/Analítica 3 para dummies /db_movies') as conn:
  conn.execute("DROP TABLE IF EXISTS ratings_final")
  conn.execute("""CREATE TABLE ratings_final as
                  SELECT ratings.userId, movieId, rating, cnt_rat_user   
                  FROM ratings
                  inner join usuarios_sel
                  on ratings.userId = usuarios_sel.userId
                  """)

pd.read_sql('select * from ratings_final', conn)

# Base de datos final con todas las variables 
conn.execute("DROP TABLE IF EXISTS full_ratings")
with sql.connect('/content/drive/MyDrive/Analítica 3 para dummies /db_movies') as conn:
  conn.execute("DROP TABLE IF EXISTS full_ratings")
  conn.execute("""CREATE TABLE full_ratings as
                  SELECT userId, movies_final.movieId, title, genres, rating  
                  FROM movies_final
                  inner join ratings_final
                  on movies_final.movieId = ratings_final.movieId
                  """)

df = pd.read_sql('select * from full_ratings', conn)
df

# Separación de los generos a columnas independientes 
from mlxtend.preprocessing import TransactionEncoder
 
genres= df['genres'].str.split('|')
te = TransactionEncoder()
genres = te.fit_transform(genres)
genres = pd.DataFrame(genres, columns = te.columns_)
genres

# Union de los generos separados con la base de datos final 
df_final = pd.concat([df,genres], axis=1)
df_final = df_final.drop(['genres'], axis=1)
df_final

# Función str.extract() para extraer el año de la columna 'title' en otra columna
df_final['year'] = df_final['title'].str.extract(r'\((\d{4})\)')

# Función str.replace() para eliminar el texto entre paréntesis de "title"
df_final['title'] = df_final['title'].str.replace(r'\s*\([^()]*\)', '', regex=True)

df_final

# guardar base datos en sql 
df_final.to_sql('df_final', conn, if_exists='replace')

"""### **Recomendaciones basadas en popularidad**"""

#### mejores peliculas calificadas ####
pd.read_sql("""select title, 
            avg(rating) as avg_rat,
            count(*) as view_num
            from df_final
            group by title
            order by avg_rat desc
            limit 10
            """, conn)

#### los mejores calificados por año de publicacion ####
pd.read_sql("""
    SELECT year, title, avg_rat, view_num
    FROM (
        SELECT year, title, AVG(rating) AS avg_rat, COUNT(*) AS view_num,
        RANK() OVER (PARTITION BY year ORDER BY AVG(rating) DESC) AS rnk
        FROM df_final
        GROUP BY year, title
    ) subquery
    WHERE rnk = 1
    ORDER BY year DESC
""", conn)

### Pelicula con la mejor calificacion por genero ###
pd.read_sql("""SELECT title, cal, genero
FROM (
  SELECT title, AVG(rating) as cal, 
         CASE WHEN Action = True THEN 'Accion'
              WHEN Adventure = True THEN 'Aventura'
              WHEN Animation = True THEN 'Animacion'
              WHEN Children = True THEN 'Infantil'
              WHEN Comedy = True THEN 'Comedia'
              WHEN Crime = True THEN 'Crimen'
              WHEN Documentary = True THEN 'Documental'
              WHEN Drama = True THEN 'Drama'
              WHEN Fantasy = True THEN 'Fantasia'
              WHEN Horror = True THEN 'Horror'
              WHEN IMAX = True THEN 'Imax'
              WHEN Musical = True THEN 'Musical'
              WHEN Mystery = True THEN 'Misterio'
              WHEN Romance = True THEN 'Romance'
              WHEN Thriller = True THEN 'Thrill'
              WHEN War = True THEN 'Guerra'
              WHEN Western = True THEN 'Occidental'
              WHEN "Sci-Fi" = True THEN 'Ciencia ficcion'
              WHEN "Film-Noir" = True THEN 'Cine negro'

         END as genero,
         ROW_NUMBER() OVER (PARTITION BY 
                            CASE WHEN Action = True THEN 'Accion'
                                 WHEN Adventure = True THEN 'Aventura'
                                 WHEN Animation = True THEN 'Animacion'
                                 WHEN Children = True THEN 'Infantil'
                                 WHEN Comedy = True THEN 'Comedia'
                                 WHEN Crime = True THEN 'Crimen'
                                 WHEN Documentary = True THEN 'Documental'
                                 WHEN Drama = True THEN 'Drama'
                                 WHEN Fantasy = True THEN 'Fantasia'
                                 WHEN Horror = True THEN 'Horror'
                                 WHEN IMAX = True THEN 'Imax'
                                 WHEN Musical = True THEN 'Musical'
                                 WHEN Mystery = True THEN 'Misterio'
                                 WHEN Romance = True THEN 'Romance'
                                 WHEN Thriller = True THEN 'Thrill'
                                 WHEN War = True THEN 'Guerra'
                                 WHEN Western = True THEN 'Occidental'
                                 WHEN "Sci-Fi" = True THEN 'Ciencia ficcion'
                                 WHEN "Film-Noir" = True THEN 'Cine negro'
                            END 
                            ORDER BY AVG(rating) DESC) as num
  FROM df_final
  WHERE Action = True OR Adventure = True OR Animation = True OR Children = True OR Comedy = True OR Crime = True OR Documentary = True 
  OR Drama = True OR Fantasy = True OR Horror = True OR IMAX = True OR Musical = True OR Mystery = True OR Romance = True OR Thriller = True 
  OR War = True OR Western = True OR "Sci-Fi" = True OR "Film-Noir" = True
  GROUP BY title, genero
) t
WHERE num = 1
          """,conn)

"""### **Recomendación basada en contenido de un producto**




"""

columnas = ~df_final.columns.isin(['userId','movieId','rating','title','year'])
df_final.iloc[:,columnas] = df_final.iloc[:,columnas].astype(int)
df_final

# Base de datos con Titulo, rating, generos y año de las peliculas 
df_final2= df_final.loc[:,~df_final.columns.isin(['userId','movieId'])]

df_final2

df_final2.to_sql('df_final2', conn, if_exists='replace')

# agrupacion de la base df_final2 por titulo y año
R_year = pd.read_sql("""select *, avg(rating) as avg_rat
                      from df_final2
                      group by year, title 
                      order by year desc, avg_rat desc""", conn)
R_year

# convertir columna 'year' a tipo entero y escalarlo
from sklearn.preprocessing import MinMaxScaler
from ipywidgets import interact
R_year['year']=R_year.year.astype('int')
sc=MinMaxScaler()
R_year[["year_"]]=sc.fit_transform(R_year[['year']])

# borrar variables innecesarias: el año sin escalar, las calificaciones y el index
R_year_dum1=R_year.drop(columns=['year','rating','avg_rat','index'])
R_year_dum1

# convertir a dummies el nombre de las peliculas
R_year_dum2=pd.get_dummies(R_year_dum1,columns=['title'])
R_year_dum2

# recomendacion de las primeras 10 peliculas con mayor similitud en contenido 
def recomendacion(movie = list(R_year['title'])):
     
    ind_movie=R_year[R_year['title']==movie].index.values.astype(int)[0]   
    similar_movie = R_year_dum2.corrwith(R_year_dum2.iloc[ind_movie,:],axis=1)
    similar_movie = similar_movie.sort_values(ascending=False)
    top_similar_movie=similar_movie.to_frame(name="correlación").iloc[0:11,]
    top_similar_movie['title']=R_year["title"]
    
    return top_similar_movie
print(interact(recomendacion))

#### 2.1 Sistema de recomendación basado en contenido con KNN ####

from sklearn import neighbors
model = neighbors.NearestNeighbors(n_neighbors=20, metric='cosine')
model.fit(R_year_dum2)
dist, idlist = model.kneighbors(R_year_dum2)

distancias=pd.DataFrame(dist)
id_list=pd.DataFrame(idlist)


def movieRecommender(movie_name = list(R_year['title'].value_counts().index)):
    movie_list_name = []
    movie_id = R_year[R_year['title'] == movie_name].index
    movie_id = movie_id[0]
    for newid in idlist[movie_id]:
        movie_list_name.append(R_year.loc[newid].title)
    return movie_list_name


print(interact(movieRecommender))

"""##**Sistema de recomendación basado en contenido KNN con base en todo lo visto por el usuario**"""

# reutilizar base de datos df_final
df_final

# sacar el id del usuario 
df_final = df_final.loc[:,~df_final.columns.isin(['userId'])]

# guardar en sql
df_final.to_sql('df_final', conn, if_exists='replace')

# agrupar base de datos por titulo y año 
movies = pd.read_sql("""select *, avg(rating) as avg_rat
                      from df_final
                      group by year, title 
                      order by year desc, avg_rat desc""", conn)

# eliminar el indice y la calificaciones asociadas a las peliculas 
movies = movies.drop(columns=['index','rating','avg_rat'])

movies

# convertir year a tipo entero 
movies['year'] = movies['year'].astype('int')

##### escalar la variable año para que esté en el mismo rango ###
sc=MinMaxScaler()
movies[["year_sc"]]=sc.fit_transform(movies[['year']])

## eliminar filas que no se van a utilizar ###
movies_dum1=movies.drop(columns=['movieId','title','year'])

movies_dum1

# variable con los usuarios unicos
usuarios=pd.read_sql('select distinct (userId) as user_id from ratings_final',conn)

# recomendacion de 10 peliculas de acuerdo al perfil del usuario 
def recomendar(user_id=list(usuarios['user_id'].value_counts().index)):
    
    ###seleccionar solo los ratings del usuario seleccionado
    ratings=pd.read_sql('select *from ratings_final where userId=:user',conn, params={'user':user_id})
    ###convertir ratings del usuario a array
    l_movies_r=ratings['movieId'].to_numpy()
    
    ###agregar la columna de movieId y titulo de la pelicula a dummie para filtrar y mostrar nombre
    movies_dum1[['movieId','title']]=movies[['movieId','title']]
    movies_r=movies_dum1[movies_dum1['movieId'].isin(l_movies_r)]
    movies_r=movies_r.drop(columns=['movieId','title'])
    movies_r["indice"]=1 
    centroide=movies_r.groupby("indice").mean()
    
    movies_nr=movies_dum1[~movies_dum1['movieId'].isin(l_movies_r)]
    movies_nr=movies_nr.drop(columns=['movieId','title'])
    model=neighbors.NearestNeighbors(n_neighbors=11, metric='cosine')
    model.fit(movies_nr)
    dist, idlist = model.kneighbors(centroide)
    
    ids=idlist[0]
    recomend_m=movies.loc[ids][['title','movieId']]
    vistos=movies[movies['movieId'].isin(l_movies_r)][['title','movieId']]
    
    return recomend_m

print(interact(recomendar))

"""##**Sistema de recomendación filtro colaborativo basado en item**"""

# base de dators con el usuario, el codigo de la pelicula y la calificacion
ratings=pd.read_sql('select * from ratings_final', conn)
ratings= ratings.drop(columns=['cnt_rat_user'])
ratings

###### leer datos desde tabla de pandas
reader = Reader(rating_scale=(0, 5))

###las columnas deben estar en orden estándar: user item rating
data = Dataset.load_from_df(ratings[['userId','movieId','rating']], reader)

ratings=pd.read_sql('select * from ratings_final', conn)
pd.read_sql('select avg(rating) from ratings_final', conn) ## promedio de ratings
###### leer datos desde tabla de pandas
reader = Reader(rating_scale=(0, 5))

# evaluar varios modelos 
models=[KNNBasic(),KNNWithMeans(),KNNWithZScore(),KNNBaseline()] 
results = {}

# determinar el mejor modelo 
for model in models:
 
    CV_scores = cross_validate(model, data, measures=["MAE","RMSE"], cv=5)  
    result = pd.DataFrame.from_dict(CV_scores).mean(axis=0).\
             rename({'test_mae':'MAE', 'test_rmse': 'RMSE'})
    results[str(model).split("algorithms.")[1].split("object ")[0]] = result


performance_df = pd.DataFrame.from_dict(results).T
performance_df.sort_values(by='RMSE')

# ajuste de hiperparamteros
param_grid = { 'sim_options' : {'name': ['msd','cosine'], \
                                'min_support': [5], \
                                'user_based': [False, True]}
             }
# implementacion de gridsearch para el modelo KNNBaseline
gridsearchKNNBaseline = GridSearchCV(KNNBaseline, param_grid, measures=['rmse'], \
                                      cv=2)
                                    
gridsearchKNNBaseline.fit(data)


print(gridsearchKNNBaseline.best_params["rmse"])
print(gridsearchKNNBaseline.best_score["rmse"])
gs_model=gridsearchKNNBaseline.best_estimator['rmse'] ### mejor estimador de gridsearch

################# Realizar predicciones

trainset = data.build_full_trainset() ### función que convierte todos los datos en entrenamiento
model=gs_model.fit(trainset) ## se entrena sobre todos los datos posibles
predset = trainset.build_anti_testset()
predictions = model.test(predset)

predictions_df = pd.DataFrame(predictions) ### tabla con todas las predicciones
print(predictions_df.shape)
print(predictions_df.head())
print(predictions_df['r_ui'].unique()) ### promedio de ratings
print(predictions_df.sort_values(by='est',ascending=False))

##### funcion para recomendar los 10 libros con mejores predicciones y llevar base de datos para consultar resto de información
def recomendaciones(user_id,n_recomend=10):
    
    predictions_userID = predictions_df[predictions_df['uid'] == user_id].\
                    sort_values(by="est", ascending = False).head(n_recomend)

    recomendados = predictions_userID[['iid','est']]
    recomendados.to_sql('reco',conn,if_exists="replace")
    
    recomendados=pd.read_sql('''select a.*, b.title 
                             from reco a left join movies b
                             on a.iid=b.movieId ''', conn)

    return(recomendados)

# recomendacion de 20 peliculas que no ha visto al usuario 171 
us1=recomendaciones(user_id=171,n_recomend=20)
us1